## Новый базис

Можно ли в двумерном пространстве понять, как точки расположены друг относительно друга? Если рассматривать точки A и B относительно оси X = (1.0, 0.0), то в случае, когда координата x вектора `dirToB = A - B` больше нуля, можно сказать, что точка B находится правее точки A.
А если точкам A и B задать радиусы r<sub>A</sub> и r<sub>B</sub> соответственно, то окружность с центром в точке B будет загораживать окружность с цетром в точке A в том случае, когда ещё и `length(dirToB.y) < (r<sub>A</sub> + r<sub>B</sub>)`.

В качестве оси, вдоль которой нужно рассмотреть расположение частиц, необходимо взять направление света sunDir. И чтобы описанные выше принципы определения взаимного расположения частиц сработали, необходимо изменить и другие вектора базиса. Для двумерного пространства это несложно, поэтому сразу стоит ставить вопрос о трехмерном пространстве.

При заданном векторе sunDir существует бесконечное множество перпендикулярных ему векторов. Зафиксируем это на координатной трехмерной плоскости, перпендикулярной вектору sunDir. В этом случае любой ненулевой вектор из этой плоскости перпендикулярен вектору sunDir.
Назовем такой вектор up. Чтобы проверить неколлинеарность, можно воспользоваться свойством скалярного произведения: `dot(up, sunDir) = 0`, когда угол между up и sunDir равен Pi/2. Например, если sunDir = (1, 0, 0), то up = (0, 1, 1). А если sunDir = (0, -1, 0), то up = (1, 0, 1). 

sunDir - нормализованный вектор, и это свойство поможет вычислить вектор up как можно быстрее. Необходимо инвертировать значение координаты вектора sunDir: 1 станет 0, а 0 станет 1. Если координата отрицательная, т.е. -1, то она так же становится 0. Значение хранится в младшем бите числа, поэтому можно воспользоваться логической операцией XOR, чтобы быстро его изменить. В качестве маски берется или 1, или -1 в зависимости от знака координаты sunDir.
Но логические операции применимы только к целочисленным типам, следовательно, нужно конвертировать float в int. Так как хранятся в векторе sunDir только единицы и нули, ничего не потеряется. 

Необходимо помнить о том, что базисный вектор не может быть нулевым. И если sunDir = (1, 1, 1), то, руководствуясь описанной выше логикой, получится up = (0, 0, 0). Когда вектор up нулевой, необходимо подобрать такие координаты, при которых dot(sunDir, up) = 0.

Первой координатой всегда будет 0, двумя последними будут единицы. Знаки этих единиц зависят от знаков единиц вектора sunDir. Если sunDir = (1, -1, 1), то up = (0, 1, 1), а если sunDir = (1, 1, 1), то up = (0, -1, 1):
```
if (Sign(sunDirY) == Sign(sunDirZ))
{
    up = float3(0.0f, -1.0f, 1.0f);
}
else
{
    up = float3(0.0f, 1.0f, 1.0f);
}
```

Третий вектор базиса можно сформировать с помощью векторного произведения уже имеющихся векторов:
```
float3 forward = cross(sunDir, up) 
```

Теперь нужно вычислить позиции частиц в новом базисе. Это возможно с помощью скалярного произведения, которое возвращает длину проекции одного вектора на другой. А значит, спроецируем позицию частицы на новые оси:
```
float3 sunBasisPos = float3(
    dot(curPos, sunDir),
    dot(curPos, up),
    dot(curPos, forward)
);
```

После записи вычисления обновленных позиций, необходимо подождать, пока все потоки не завершат операцию записи в groupshared память: `GroupMemoryBarrierWithGroupSync()`. (В случае, когда количество потоков в группе не больше, чем GPU's native wave size, можно использовать просто GroupMemoryBarrier(). Однако не все драйвера нормально отреагируют на такое, поэтому GroupMemoryBarrier() был бы не самым переносимым решением, несмотря на подходящее количество потоков.) 

И теперь, когда sunDir является одной из осей базиса, в котором находятся все частицы, можно применить вычисления, описанные в самом начале:
```
float otherRadius = sbParticles[i].radius;

float3 sunBasisOtherPos = sunBasis[i];

float3 dirToOther = sunBasisOtherPos - sunBasisPos;

if (dirToOther.x > 0.0f && length(dirToOther.yz) < radius + otherRadius)
{
  // sunBasisOtherPos затеняет sunBasisPos
```

Мы сравниваем с нулем координату x вектора dirToOther, т.к. именно координату x частицы в исходном базисе была спроецирована на ось sunDir. Поэтому сравнение dirToOther.x сработает для любого направления sunDir. 

Такой вариант затенения достаточно гибкий. Во-первых, при вычислении затенения методом пересечения луча с другими частицами, необходимо было рассматривать случай, когда обнаружилось пересечение за частицей. Здесь же этот случай обрабатывается условием if (dirToOther.x > 0). Во-вторых, от условия if (length(dirToOther.yz < radius + otherRadius)) зависит освещенность. Этот if игнорирует те случаи, когда другая частица перекрывает рассматриваемую меньше чем на половину, что отличается от алгоритма пересечения луча с другими частицами (поэтому затенение теперь выглядит немного по-другому).     

> Прозрачность всех частиц = 0.2, стадия смешивания цветов включена 

![](img/sunbasis-demo.png)

Такая модификация повысила производительность больше чем на 40% на моей видеокарте (Intel Integrated UHD 620). Узким местом является рассчет нового базиса, который осуществляется каждый кадр, хотя следовало бы перенести это на CPU и считать только в том случае, когда обновляется вектор sunDir. Затем передавать вектора sunDir, up и forward в вычислительный шейдер, чтобы пересчитывать координаты частиц в новом пространстве. Можно подумать еще и о том, чтобы вычислять позиции частиц для sunBasis тоже только в том случае, когда исходные позиции изменяются. 

## Прозрачность частицы

Мы хотим, чтобы в случае, когда полностью непрозрачная частица (opacity = 1.0) дает тень, sbShadows равнялось 0. А если частица с прозрачностью 0.0 затеняет, то sbShadows должно быть 1 (то есть тени нет). Получается такая формула:
```
shadow *= (1.0f - otherParticle.opacity);
```
которую тоже можно изменять, добавляя коэффициенты. 

Здесь, слева направо, у частиц прозрачности 1.0, 0.5, 0.25 (стадия смешивания в конвейере включена):

![](img/three-particles-opacity.png)

## [Исходный шейдер](https://github.com/naiderrp/DirectX12-Self-shadowed-Particle-System/blob/main/src/direct-test/ComputeShader_SunBasis.hlsl)
