> Дан структурный буфер частиц в размере от 2 до 1024 элементов. Каждый партикл имеет радиус больше 0, и непрозрачность от 0 до 1 (1 - полностью непрозрачный). Расстояния между партиклами сопоставимы с их радиусами. Направление на солнце задано нормализованным вектором sunDir. Система координат: X-вперед, Y-вверх, Z-вправо.

#### 1. Предложите варианты расчета самозатенения системы частиц

- Сортировка. Можно предварительно отсортировать частицы по мере их удаления от источника света. А затем в `sbShadows[i]` записать `sbShadows[i+1] * 0.7`. Подойдёт только в том случае, когда положение ни одной из частиц в системе не меняется динамически.

- Карта теней. Подойдёт, скорее, для быстрого вычисления тени, отбрасываемой самой системой.

- Grid-based. Можно разбить пространство на сетку и рассчитать, сколько света проходит через каждую ячейку. Не подойдёт в случае неравномерного распределения частиц. Если система динамичная, постоянное обновление сетки приведёт к падению производительности.

- Трассировка лучей. Если в пиксельном шейдере луч направляется в каждый пиксель, то в вычислительном в качестве пикселя можно использовать частицу целиком.

#### 2. Напишите на hlsl оптимальный по быстродействию compute шейдер (Shading Model 5) с расчетом самозатенения частиц, результат вычислений записать в sbShadows. sbShadows имеет такое же количество элементов что и sbParticles, индексы совпадают.

Каждая частица представлена окружностью (сферой). Если провести прямую из центра частицы `p0` в сторону источника света, то количество других частиц (сфер), которые пересечёт эта прямая и будет влиять на яркость частицы.
Это можно выразить одним уравнением:

`t^2 * (bx^2 + by^2 + bz^2) + t * 2 * (bx * (ax - x0) + by * (ay - y0) + bz * (az - z0)) + ((ax - x0)^2 + (ay - y0)^2 + (az - z0)^2 - r^2) = 0`

`r` – радиус частицы `p1`, которая, предположительно, перекрывает частицу `p0`

`х0`, `у0`, `z0` – координаты центра частицы `p1`

`ax`, `ay`, `az` – координаты начала прямой (от центра `p0` к источнику света)

`bx`, `by`, `bz` – направление прямой (от центра `p0` к источнику света)

`t` – исходная точка ближайшего пересечения, которую необходимо найти (достаточно просто знать, есть ли она).

Но если сравнивать каждую частицу с остальными, потребуется `O(n^n)` итераций для каждого потока, что, конечно, слишком много, когда частиц больше 10-ти. 
Решение можно оптимизировать: частицы, с которыми пересечение невозможно, отбрасываются. 

(Пример ниже для двухмерного пространства, готовый вариант отмасштабирован на трёхмерное)

В случае, когда источник света находится правее от частицы, нет смысла рассматривать пересечение с теми частицами, что находятся левее. Получается, что (слева направо) для первой частицы будет проанализировано пересечение с двумя окружностями, для второй – с одной, а для третьей вообще ни с чем.

Если высчитать сложность после оптимизации, исходя из _худшего_ случая (когда все частицы в ряд друг за другом, то есть каждая, кроме последней, затенена), получается:

`1 + 2 + 3 + ... + 1023 + 1024 = n * (a_1 + n) / 2 = n / 2 + n^2 / 2 = O(n^2).`

Если рассматривать готовый пример и то, как повлияли изменения на него: 
На моей видеокарте (Intel Integrated UHD 620) для системы из 1024 частиц такая оптимизация повысила производительность почти в 6 раз.

После стадии вычислительного шейдера можно прочитать данные из буфера, находящегося в VRAM, назад, в RAM, и посмотреть, сколько частиц было пропущено в цикле. В итоговой демонстрации, в среднем, для каждой частицы было пропущено 700 итераций. (До оптимизации на каждый поток приходилось по 1000+ итераций, после – по 200. Этим и объясняется прирост более чем в 5 раз)

#### Модификация

Рассмотренный выше алгоритм достаточно универсален: не имеет значения ни радиус частиц, ни то, насколько далеко они друг от друга. Но если наложить на систему некоторые ограничения, можно снова получить прирост.
Если частицы находятся друг от друга на расстоянии, не большем чем радиус, нужно, вдоль всё той же прямой от центра частицы `p0` к источнику света, отступить `t = 2 * radius`. И если получившаяся точка принадлежит окружности частицы `p1`, то `p1` затеняет `p0`. И в `sbShadows[p0]` запишется значение `shShadows[p1] * 0.7`
Но есть недостаток:
Что, если в момент чтения `sbShadows[p1]` другой поток делает туда запись? Что, если корректное затенение для p1 ещё не вычислено? Необходимо синхронизировать операции чтения-записи ячейки памяти, из-за чего модификация алгоритма приводит к незначительному приросту производительности. Всего 15% на моей видеокарте.
